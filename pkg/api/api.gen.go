//go:build go1.22

// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for ActivityPeriod.
const (
	All   ActivityPeriod = "all"
	Day   ActivityPeriod = "day"
	Month ActivityPeriod = "month"
	Week  ActivityPeriod = "week"
)

// Defines values for ActivitySortBy.
const (
	CreationDate ActivitySortBy = "creationDate"
	Similarity   ActivitySortBy = "similarity"
)

// Defines values for SourceType.
const (
	ChangedetectionWebsite SourceType = "changedetectionWebsite"
	GithubIssues           SourceType = "githubIssues"
	GithubReleases         SourceType = "githubReleases"
	HackernewsPosts        SourceType = "hackernewsPosts"
	LobstersFeed           SourceType = "lobstersFeed"
	LobstersTag            SourceType = "lobstersTag"
	MastodonAccount        SourceType = "mastodonAccount"
	MastodonTag            SourceType = "mastodonTag"
	RedditSubreddit        SourceType = "redditSubreddit"
	RssFeed                SourceType = "rssFeed"
)

// ActivitiesListResponse defines model for ActivitiesListResponse.
type ActivitiesListResponse struct {
	// HasMore Whether there are more results available
	HasMore *bool `json:"hasMore,omitempty"`

	// NextCursor Cursor to use for fetching the next page of results
	NextCursor *string         `json:"nextCursor,omitempty"`
	Results    []Activity      `json:"results"`
	Topics     []ActivityTopic `json:"topics"`
}

// Activity defines model for Activity.
type Activity struct {
	Body      string    `json:"body"`
	CreatedAt time.Time `json:"createdAt"`

	// FullSummary One-paragraph markdown summary.
	FullSummary string `json:"fullSummary"`
	ImageUrl    string `json:"imageUrl"`

	// ShortSummary One-line short plain text summary.
	ShortSummary string `json:"shortSummary"`

	// Similarity Similarity score (0-1) when using semantic search
	Similarity *float32   `json:"similarity,omitempty"`
	SourceType SourceType `json:"sourceType"`
	SourceUid  string     `json:"sourceUid"`
	Title      string     `json:"title"`
	Uid        string     `json:"uid"`
	Url        string     `json:"url"`
}

// ActivityPeriod Time period to filter activities from. 'month' means last month, 'week' means last week, 'day' means last day.
type ActivityPeriod string

// ActivitySortBy defines model for ActivitySortBy.
type ActivitySortBy string

// ActivityTopic defines model for ActivityTopic.
type ActivityTopic struct {
	// ActivityIds List of activity IDs in this topic.
	ActivityIds []string `json:"activityIds"`

	// Queries LLM generated sub-queries used to filter activities for this topic.
	Queries []string `json:"queries"`

	// Summary Summary of the activities in this topic.
	Summary string `json:"summary"`

	// Title Title of the topic.
	Title string `json:"title"`
}

// CreateFeedRequest defines model for CreateFeedRequest.
type CreateFeedRequest struct {
	Icon       string   `json:"icon"`
	Name       string   `json:"name"`
	Query      string   `json:"query"`
	SourceUids []string `json:"sourceUids"`
}

// Feed defines model for Feed.
type Feed struct {
	CreatedAt time.Time `json:"createdAt"`

	// CreatedBy ID of the user who created and owns the feed. Feed can only be modified by him.
	CreatedBy  string   `json:"createdBy"`
	Icon       string   `json:"icon"`
	IsPublic   bool     `json:"isPublic"`
	Name       string   `json:"name"`
	Query      string   `json:"query"`
	SourceUids []string `json:"sourceUids"`
	Uid        string   `json:"uid"`
}

// Source defines model for Source.
type Source struct {
	Description string     `json:"description"`
	IconUrl     string     `json:"iconUrl"`
	Name        string     `json:"name"`
	Type        SourceType `json:"type"`
	Uid         string     `json:"uid"`
	Url         string     `json:"url"`
}

// SourceType defines model for SourceType.
type SourceType string

// UpdateFeedRequest defines model for UpdateFeedRequest.
type UpdateFeedRequest = CreateFeedRequest

// ListFeedActivitiesParams defines parameters for ListFeedActivities.
type ListFeedActivitiesParams struct {
	// Period Time period to filter activities from. Defaults to 'all' for all time.
	Period *ActivityPeriod `form:"period,omitempty" json:"period,omitempty"`

	// SortBy Sort method.
	SortBy *ActivitySortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// Query Filter query. Authenticated users can override the default feed query.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit Maximum number of activities to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListSourcesParams defines parameters for ListSources.
type ListSourcesParams struct {
	// Query Filter sources by name or description.
	Query *string `form:"query,omitempty" json:"query,omitempty"`
}

// CreateOwnFeedJSONRequestBody defines body for CreateOwnFeed for application/json ContentType.
type CreateOwnFeedJSONRequestBody = CreateFeedRequest

// UpdateOwnFeedJSONRequestBody defines body for UpdateOwnFeed for application/json ContentType.
type UpdateOwnFeedJSONRequestBody = UpdateFeedRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List public feeds and/or those belonging to the authenticated user
	// (GET /feeds)
	ListFeeds(w http.ResponseWriter, r *http.Request)
	// Create a feed belonging to the authenticated user
	// (POST /feeds)
	CreateOwnFeed(w http.ResponseWriter, r *http.Request)
	// Delete a feed belonging to the authenticated user
	// (DELETE /feeds/{uid})
	DeleteOwnFeed(w http.ResponseWriter, r *http.Request, uid string)
	// Update a feed belonging to the authenticated user
	// (PUT /feeds/{uid})
	UpdateOwnFeed(w http.ResponseWriter, r *http.Request, uid string)
	// List activities for a feed
	// (GET /feeds/{uid}/activities)
	ListFeedActivities(w http.ResponseWriter, r *http.Request, uid string, params ListFeedActivitiesParams)
	// List available sources
	// (GET /sources)
	ListSources(w http.ResponseWriter, r *http.Request, params ListSourcesParams)
	// Get source by UID
	// (GET /sources/{uid})
	GetSource(w http.ResponseWriter, r *http.Request, uid string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListFeeds operation middleware
func (siw *ServerInterfaceWrapper) ListFeeds(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListFeeds(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOwnFeed operation middleware
func (siw *ServerInterfaceWrapper) CreateOwnFeed(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOwnFeed(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteOwnFeed operation middleware
func (siw *ServerInterfaceWrapper) DeleteOwnFeed(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "uid", r.PathValue("uid"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uid", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteOwnFeed(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateOwnFeed operation middleware
func (siw *ServerInterfaceWrapper) UpdateOwnFeed(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "uid", r.PathValue("uid"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uid", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateOwnFeed(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListFeedActivities operation middleware
func (siw *ServerInterfaceWrapper) ListFeedActivities(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "uid", r.PathValue("uid"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uid", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFeedActivitiesParams

	// ------------- Optional query parameter "period" -------------

	err = runtime.BindQueryParameter("form", true, false, "period", r.URL.Query(), &params.Period)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "period", Err: err})
		return
	}

	// ------------- Optional query parameter "sortBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortBy", r.URL.Query(), &params.SortBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sortBy", Err: err})
		return
	}

	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", r.URL.Query(), &params.Query)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "query", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListFeedActivities(w, r, uid, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListSources operation middleware
func (siw *ServerInterfaceWrapper) ListSources(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSourcesParams

	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", r.URL.Query(), &params.Query)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "query", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSources(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSource operation middleware
func (siw *ServerInterfaceWrapper) GetSource(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "uid", r.PathValue("uid"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uid", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSource(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/feeds", wrapper.ListFeeds)
	m.HandleFunc("POST "+options.BaseURL+"/feeds", wrapper.CreateOwnFeed)
	m.HandleFunc("DELETE "+options.BaseURL+"/feeds/{uid}", wrapper.DeleteOwnFeed)
	m.HandleFunc("PUT "+options.BaseURL+"/feeds/{uid}", wrapper.UpdateOwnFeed)
	m.HandleFunc("GET "+options.BaseURL+"/feeds/{uid}/activities", wrapper.ListFeedActivities)
	m.HandleFunc("GET "+options.BaseURL+"/sources", wrapper.ListSources)
	m.HandleFunc("GET "+options.BaseURL+"/sources/{uid}", wrapper.GetSource)

	return m
}
